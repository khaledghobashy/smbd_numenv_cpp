
#include "$file_name.hpp"

// ============================================================================
//                     Configuration Class Implementation
// ============================================================================

typedef Eigen::SparseMatrix<double, Eigen::ColMajor> SparseBlock;


Configuration::Configuration()
    :
        ConfigInputs()
    {}

void Configuration::constructFromJSON(const std::string& fileName)
{
    ConfigInputs.constructFromJSON(fileName);
    populateArguments();
};


void Configuration::populateArguments()
{
    $primary_arguments
};


void Configuration::set_inital_configuration()
{
    R_ground << 0, 0, 0 ;
    P_ground << 1, 0, 0, 0 ;

    q.resize($n);
    q << 
        $q_equalities;

    qd.resize($n);
    qd << 
        $qd_equalities;
};

// ============================================================================
//                     Coordinates Struct Constructor
// ============================================================================

Coordinates::Coordinates(Eigen::Ref<Eigen::VectorXd> _q, 
                         Eigen::Ref<Eigen::VectorXd> _qd, 
                         Eigen::Ref<Eigen::VectorXd> _qdd,
                         Eigen::Ref<Eigen::VectorXd> _lgr)
    : // Initializer list initializing the needed struct memebrs.
        q(_q), qd(_qd), qdd(_qdd), lgr(_lgr)
    {};


// ============================================================================
//                     Topology Class Implementation
// ============================================================================

// Topology Constructor
// ====================
Topology::Topology(std::string name, 
            Eigen::Ref<Eigen::VectorXd> q, 
            Eigen::Ref<Eigen::VectorXd> qd, 
            Eigen::Ref<Eigen::VectorXd> qdd,
            Eigen::Ref<Eigen::VectorXd> lgr)

    : // Initializer list initializing the needed struct memebrs.
        prefix(name), coord(q, qd, qdd, lgr), config()

{
    pos_eq.resize(nc);
    vel_eq.resize(nc);
    acc_eq.resize(nc);
    frc_eq.resize(n);
    rct_eq.resize(6*$n_joints);

    jac_rows.resize($nnz);
    jac_cols.resize($nnz);
    jac_eq.reserve($nnz);

    mas_eq.reserve(2*ncols);
};

// Topology initializer and assembler
// ==================================
void Topology::initialize()
{
    Dict_SS interface_map;
    map_indicies();
    assemble(indicies_map, interface_map, 0);
    coord.q << config.q;
    eval_constants();
};

void Topology::map_indicies()
{
    int i = 0;
    for (auto& name : bodies_names) {indicies_map[prefix + name] = i; i++;};
};


void Topology::assemble(Dict_SI& indicies_map, Dict_SS& interface_map, int rows_offset)
{
    set_mapping(indicies_map, interface_map);

    jac_rows << $jac_rows;
    jac_rows += (rows_offset * Eigen::VectorXi::Ones(jac_rows.size()) );

    jac_cols << 
        $jac_cols;
};


void Topology::set_mapping(Dict_SI& indicies_map, Dict_SS& interface_map)
{
    auto& p = this-> prefix;

    $indicies_map

    $virtuals
};


void Topology::eval_constants()
{
    $num_constants
                    
    $sym_constants
};

void Topology::eval_pos_eq()
{
    $pos_replacements

    pos_eq << 
        $pos_expressions;
};

void Topology::eval_vel_eq()
{
    $vel_replacements

    vel_eq << 
        $vel_expressions;
};

void Topology::eval_acc_eq()
{
    $acc_replacements

    acc_eq << 
        $acc_expressions;
};

void Topology::eval_frc_eq()
{
    $frc_replacements

    frc_eq << 
        $frc_expressions;
};

void Topology::eval_jac_eq()
{
    $jac_replacements

    jac_eq = 
        $jac_expressions;
};

void Topology::eval_mas_eq()
{
    $mas_replacements

    mas_eq = 
        $mas_expressions;
};


void Topology::eval_reactions()
{
    $rct_expressions1

    //$rct_return1;
};

void Topology::eval_reactions(Eigen::Ref<SparseBlock> jacobian)
{
    $rct_expressions2

    rct_eq << $rct_return2;
};